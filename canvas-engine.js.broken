/**
 * Canvas Engine - Complete infinite canvas implementation
 * Supports: Select, Hand, Page, Image, Text, Shapes (Rectangle/Line/Arrow/Ellipse/Polygon/Star), Pencil
 */

class CanvasEngine {
    constructor(canvasElement) {
        this.canvas = canvasElement;
        this.ctx = canvasElement.getContext('2d');

        // Viewport state
        this.viewport = {
            x: 0,
            y: 0,
            scale: 0.2,
            minScale: 0.02,
            maxScale: 5.0
        };

        // Canvas state
        this.elements = [];
        this.selectedElements = [];
        this.currentTool = 'move';
        this.previousTool = null; // For temporary tool switching
        this.currentShapeType = 'rectangle';

        // History for undo/redo
        this.history = {
            past: [],
            future: [],
            maxSize: 50
        };

        // Interaction state
        this.isPanning = false;
        this.isDrawing = false;
        this.isDragging = false;
        this.isResizing = false;
        this.dragStart = null;
        this.lastMousePos = null;
        this.tempElement = null;
        this.resizeHandle = null;
        this.spacePressed = false; // Track space key state
        this.isBoxSelecting = false;
        this.boxSelectStart = null;
        this.pageCounter = 0;

        // Text editing
        this.editingText = null;
        this.textInput = null;

        // Performance optimization
        this.renderScheduled = false;

        // Visual aids
        this.showPixelGrid = false;
        this.showRulers = false;
        this.autoSnap = false;

        this.init();
    }

    init() {
        this.resizeCanvas();
        window.addEventListener('resize', () => this.resizeCanvas());
        this.setupEventListeners();

        // Center viewport
        this.viewport.x = this.canvas.width / 2;
        this.viewport.y = this.canvas.height / 2;

        this.render();
        this.updateZoomDisplay();
    }

    resizeCanvas() {
        this.canvas.width = window.innerWidth;
        this.canvas.height = window.innerHeight;
        this.render();
    }

    // ==================== Coordinate Transformations ====================

    screenToWorld(screenX, screenY) {
        return {
            x: (screenX - this.viewport.x) / this.viewport.scale,
            y: (screenY - this.viewport.y) / this.viewport.scale
        };
    }

    worldToScreen(worldX, worldY) {
        return {
            x: worldX * this.viewport.scale + this.viewport.x,
            y: worldY * this.viewport.scale + this.viewport.y
        };
    }

    // ==================== Viewport Controls ====================

    pan(dx, dy) {
        this.viewport.x += dx;
        this.viewport.y += dy;
        this.render();
    }

    zoom(delta, centerX, centerY) {
        const zoomFactor = delta > 0 ? 1.1 : 0.9;
        let newScale = this.viewport.scale * zoomFactor;
        newScale = Math.max(this.viewport.minScale, Math.min(this.viewport.maxScale, newScale));

        if (newScale !== this.viewport.scale) {
            const worldPos = this.screenToWorld(centerX, centerY);
            this.viewport.scale = newScale;
            const newScreenPos = this.worldToScreen(worldPos.x, worldPos.y);

            this.viewport.x += centerX - newScreenPos.x;
            this.viewport.y += centerY - newScreenPos.y;

            // Throttled render for better performance
            this.scheduleRender();
            this.updateZoomDisplay();
        }
    }

    setZoom(scale) {
        const centerX = this.canvas.width / 2;
        const centerY = this.canvas.height / 2;
        const worldPos = this.screenToWorld(centerX, centerY);

        this.viewport.scale = Math.max(this.viewport.minScale, Math.min(this.viewport.maxScale, scale));
        const newScreenPos = this.worldToScreen(worldPos.x, worldPos.y);

        this.viewport.x += centerX - newScreenPos.x;
        this.viewport.y += centerY - newScreenPos.y;

        this.render();
        this.updateZoomDisplay();
    }

    updateZoomDisplay() {
        const zoomDisplay = document.getElementById('zoom-display');
        if (zoomDisplay) {
            zoomDisplay.textContent = `${Math.round(this.viewport.scale * 100)}%`;
        }
    }

    fitToScreen() {
        if (this.elements.length === 0) {
            this.viewport.x = this.canvas.width / 2;
            this.viewport.y = this.canvas.height / 2;
            this.viewport.scale = 0.2;
        } else {
            let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
            this.elements.forEach(el => {
                minX = Math.min(minX, el.x);
                minY = Math.min(minY, el.y);
                maxX = Math.max(maxX, el.x + el.width);
                maxY = Math.max(maxY, el.y + el.height);
            });

            const padding = 50;
            const contentWidth = maxX - minX;
            const contentHeight = maxY - minY;
            const scaleX = (this.canvas.width - padding * 2) / contentWidth;
            const scaleY = (this.canvas.height - padding * 2) / contentHeight;

            this.viewport.scale = Math.min(scaleX, scaleY, this.viewport.maxScale);
            this.viewport.x = (this.canvas.width - contentWidth * this.viewport.scale) / 2 - minX * this.viewport.scale;
            this.viewport.y = (this.canvas.height - contentHeight * this.viewport.scale) / 2 - minY * this.viewport.scale;
        }

        this.render();
        this.updateZoomDisplay();
    }

    // ==================== History ====================

    saveState() {
        const state = JSON.stringify({
            elements: this.elements
        });

        this.history.past.push(state);
        if (this.history.past.length > this.history.maxSize) {
            this.history.past.shift();
        }
        this.history.future = [];
    }

    undo() {
        if (this.history.past.length === 0) return;

        const currentState = JSON.stringify({ elements: this.elements });
        this.history.future.push(currentState);

        const prevState = JSON.parse(this.history.past.pop());
        this.elements = prevState.elements;
        this.selectedElements = [];

        this.render();
    }

    redo() {
        if (this.history.future.length === 0) return;

        const currentState = JSON.stringify({ elements: this.elements });
        this.history.past.push(currentState);

        const nextState = JSON.parse(this.history.future.pop());
        this.elements = nextState.elements;
        this.selectedElements = [];

        this.render();
    }

    // ==================== Visual Aids ====================

    togglePixelGrid() {
        this.showPixelGrid = !this.showPixelGrid;
        this.render();
    }

    toggleRulers() {
        this.showRulers = !this.showRulers;
        this.render();
    }

    toggleAutoSnap() {
        this.autoSnap = !this.autoSnap;
    }

    // ==================== Event Handlers ====================

    setupEventListeners() {
        this.canvas.addEventListener('mousedown', (e) => this.handleMouseDown(e));
        this.canvas.addEventListener('mousemove', (e) => this.handleMouseMove(e));
        this.canvas.addEventListener('mouseup', (e) => this.handleMouseUp(e));
        this.canvas.addEventListener('wheel', (e) => this.handleWheel(e));
        this.canvas.addEventListener('dblclick', (e) => this.handleDoubleClick(e));

        document.addEventListener('keydown', (e) => this.handleKeyDown(e));
        document.addEventListener('keyup', (e) => this.handleKeyUp(e));

        this.canvas.addEventListener('contextmenu', (e) => e.preventDefault());
    }

    handleMouseDown(e) {
        const rect = this.canvas.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const y = e.clientY - rect.top;
        const worldPos = this.screenToWorld(x, y);

        this.dragStart = { x, y };
        this.lastMousePos = { x, y };

        // Space key gives temporary Hand tool
        if (this.currentTool === 'hand' || e.button === 1 || this.spacePressed) {
            this.isPanning = true;
            this.canvas.style.cursor = 'grabbing';
            return;
        }

        if (this.currentTool === 'move') {
            // Check for resize handles first
            const handle = this.getResizeHandle(worldPos.x, worldPos.y);
            if (handle) {
                this.isResizing = true;
                this.resizeHandle = handle;
                this.saveState();
                return;
            }

            // Check for element selection
            const clickedElement = this.findElementAt(worldPos.x, worldPos.y);
            if (clickedElement) {
                if (!e.shiftKey) {
                    this.selectedElements = [clickedElement];
                } else {
                    const index = this.selectedElements.indexOf(clickedElement);
                    if (index >= 0) {
                        this.selectedElements.splice(index, 1);
                    } else {
                        this.selectedElements.push(clickedElement);
                    }
                }
                this.isDragging = true;
                this.saveState();
                this.render();
            } else {
                // Clicked on empty canvas - start box selection
                if (!e.shiftKey) {
                    this.selectedElements = [];
                }
                this.isBoxSelecting = true;
                this.boxSelectStart = { x, y };
                this.render();
            }
        } else {
            // Start creating new element
            this.isDrawing = true;
            this.startDrawing(worldPos.x, worldPos.y, e);
            this.saveState();
        }
    }

    handleMouseMove(e) {
        const rect = this.canvas.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const y = e.clientY - rect.top;
        const worldPos = this.screenToWorld(x, y);

        // Update cursor for resize handles
        if (this.currentTool === 'move' && this.selectedElements.length > 0 && !this.isDragging && !this.isResizing) {
            const handle = this.getResizeHandle(worldPos.x, worldPos.y);
            this.canvas.style.cursor = this.getHandleCursor(handle);
        }

        if (this.isPanning && this.lastMousePos) {
            const dx = x - this.lastMousePos.x;
            const dy = y - this.lastMousePos.y;
            this.pan(dx, dy);
        } else if (this.isResizing && this.dragStart) {
            this.updateResize(worldPos.x, worldPos.y, e);
        } else if (this.isDragging && this.dragStart) {
            const worldStart = this.screenToWorld(this.dragStart.x, this.dragStart.y);
            const dx = worldPos.x - worldStart.x;
            const dy = worldPos.y - worldStart.y;

            this.selectedElements.forEach(el => {
                if (el.type === 'path') {
                    // Move all points in the path
                    el.points.forEach(p => {
                        p.x += dx;
                        p.y += dy;
                    });
                } else {
                    // Standard x/y movement
                    el.x += dx;
                    el.y += dy;
                }
            });

            this.dragStart = { x, y };
            this.render();
        } else if (this.isDrawing && this.dragStart) {
            const worldStart = this.screenToWorld(this.dragStart.x, this.dragStart.y);
            this.updateDrawing(worldStart.x, worldStart.y, worldPos.x, worldPos.y, e);
        }

        this.lastMousePos = { x, y };
    }

    handleMouseUp(e) {
        // Box selection end
        if (this.isBoxSelecting && this.boxSelectStart) {
            const rect = this.canvas.getBoundingClientRect();
            const endX = e.clientX - rect.left;
            const endY = e.clientY - rect.top;
            const worldEnd = this.screenToWorld(endX, endY);
            const worldStart = this.screenToWorld(this.boxSelectStart.x, this.boxSelectStart.y);

            const minX = Math.min(worldStart.x, worldEnd.x);
            const maxX = Math.max(worldStart.x, worldEnd.x);
            const minY = Math.min(worldStart.y, worldEnd.y);
            const maxY = Math.max(worldStart.y, worldEnd.y);

            this.selectedElements = this.elements.filter(el => {
                if (el.type === 'path') {
                    const bounds = this.getPathBounds(el);
                    return bounds.x + bounds.width >= minX && bounds.x <= maxX &&
                        bounds.y + bounds.height >= minY && bounds.y <= maxY;
                } else if (el.type === 'shape' && (el.shapeType === 'line' || el.shapeType === 'arrow')) {
                    const minElX = Math.min(el.x, el.x2);
                    const maxElX = Math.max(el.x, el.x2);
                    const minElY = Math.min(el.y, el.y2);
                    const maxElY = Math.max(el.y, el.y2);
                    return maxElX >= minX && minElX <= maxX && maxElY >= minY && minElY <= maxY;
                } else {
                    return el.x + el.width >= minX && el.x <= maxX &&
                        el.y + el.height >= minY && el.y <= maxY;
                }
            });

            this.isBoxSelecting = false;
            this.boxSelectStart = null;
            this.render();
        }

        if (this.isDrawing && this.tempElement) {
            // Only add element if it has some size (except for text and polygon)
            if (this.tempElement.type === 'text' ||
                this.tempElement.type === 'polygon' ||
                (this.tempElement.width > 5 && this.tempElement.height > 5) ||
                (this.tempElement.type === 'path' && this.tempElement.points && this.tempElement.points.length > 2)) {
                this.elements.push(this.tempElement);

                // Auto-switch to Select tool after creating element (except for pencil)
                if (this.currentTool !== 'pencil' && this.currentTool !== 'move') {
                    this.setTool('move');
                }
            }
            this.tempElement = null;
        }

        this.isPanning = false;
        this.isDrawing = false;
        this.isDragging = false;
        this.isResizing = false;
        this.resizeHandle = null;
        this.dragStart = null;

        if (this.currentTool !== 'hand' && !this.spacePressed) {
            this.canvas.style.cursor = 'default';
        } else if (this.spacePressed) {
            this.canvas.style.cursor = 'grab';
        } else {
            this.canvas.style.cursor = 'grab';
        }

        this.render();
    }

    handleWheel(e) {
        e.preventDefault();
        const rect = this.canvas.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const y = e.clientY - rect.top;
        this.zoom(-e.deltaY, x, y);
    }

    handleDoubleClick(e) {
        if (this.currentTool !== 'move') return;

        const rect = this.canvas.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const y = e.clientY - rect.top;
        const worldPos = this.screenToWorld(x, y);

        const clickedElement = this.findElementAt(worldPos.x, worldPos.y);
        if (clickedElement && clickedElement.type === 'text') {
            this.startTextEditing(clickedElement);
        }
    }

    handleKeyDown(e) {
        // Space key for temporary Hand tool
        if (e.code === 'Space' && !this.editingText && !e.repeat) {
            e.preventDefault();
            this.spacePressed = true;
            if (!this.isPanning && !this.isDrawing) {
                this.canvas.style.cursor = 'grab';
                // Trigger UI update to show hand tool active
                this.updateToolUI('hand');
            }
            return;
        }

        // Delete selected
        if ((e.key === 'Delete' || e.key === 'Backspace') && this.selectedElements.length > 0 && !this.editingText) {
            this.saveState();
            this.selectedElements.forEach(el => {
                const index = this.elements.indexOf(el);
                if (index >= 0) this.elements.splice(index, 1);
            });
            this.selectedElements = [];
            this.render();
            e.preventDefault();
        }

        // Undo/Redo
        if ((e.metaKey || e.ctrlKey) && e.key === 'z' && !e.shiftKey && !this.editingText) {
            e.preventDefault();
            this.undo();
        }
        if ((e.metaKey || e.ctrlKey) && (e.key === 'Z' || (e.key === 'z' && e.shiftKey)) && !this.editingText) {
            e.preventDefault();
            this.redo();
        }

        // Escape to deselect
        if (e.key === 'Escape') {
            this.selectedElements = [];
            if (this.editingText) {
                this.stopTextEditing();
            }
            this.render();
        }
    }

    // Tool shortcuts - only trigger if not editing and no modifier keys
        if (this.currentTool !== 'hand') {
            this.canvas.style.cursor = 'default';
            // Restore UI to show current tool
            this.updateToolUI(this.currentTool);
        }
    }
}

// ==================== Tool Management ====================

setTool(tool) {
    this.currentTool = tool;
    this.selectedElements = [];
    this.canvas.style.cursor = tool === 'hand' ? 'grab' : 'default';
    this.updateToolUI(tool);
    this.render();
}

updateToolUI(tool) {
    // Update toolbar UI - can be overridden by canvas.js
    if (window.updateToolbarUI) {
        window.updateToolbarUI(tool);
    }
}

setShapeType(shapeType) {
    this.currentShapeType = shapeType;
}

// ==================== Drawing Tools ====================

startDrawing(worldX, worldY, e) {
    switch (this.currentTool) {
        case 'page':
            this.pageCounter++;
            const pageSize = 800;
            this.tempElement = {
                id: 'page_' + Date.now(),
                type: 'page',
                x: worldX,
                y: worldY,
                width: pageSize,
                height: pageSize,
                fill: '#FFFFFF',
                stroke: '#E5E5E5',
                strokeWidth: 1,
                label: 'Page ' + this.pageCounter
            };
            this.elements.push(this.tempElement);
            this.tempElement = null;
            this.setTool('move');
            break;

        case 'image':
            // Trigger file picker
            this.triggerImageUpload(worldX, worldY);
            // Auto-switch to Select
            this.setTool('move');
            break;

        case 'text':
            this.tempElement = {
                type: 'text',
                x: worldX,
                y: worldY,
                width: 200,
                height: 40,
                text: 'Double-click to edit',
                fontSize: 16,
                fontFamily: 'Inter',
                color: '#000000',
                align: 'left'
            };
            this.elements.push(this.tempElement);
            this.selectedElements = [this.tempElement];
            const textElement = this.tempElement;
            this.tempElement = null;
            this.render();
            // Auto-switch to Select before starting edit
            this.setTool('move');
            setTimeout(() => this.startTextEditing(textElement), 100);
            break;

        case 'rectangle':
            this.tempElement = {
                type: 'shape',
                shapeType: this.currentShapeType,
                x: worldX,
                y: worldY,
                width: 0,
                height: 0,
                fill: '#E3F2FD',
                stroke: '#2196F3',
                strokeWidth: 2,
                cornerRadius: this.currentShapeType === 'rectangle' ? 0 : undefined
            };
            break;

        case 'pencil':
            this.tempElement = {
                id: 'path_' + Date.now(),
                type: 'path',
                points: [{ x: worldX, y: worldY }],
                stroke: '#FF0000',  // Red color
                strokeWidth: 4,      // 4px width
                fill: 'none'
            };
            break;
    }
}

updateDrawing(startX, startY, currentX, currentY, e) {
    if (!this.tempElement) return;

    const shiftKey = e.shiftKey;

    switch (this.tempElement.type) {
        case 'shape':
            let width = currentX - startX;
            let height = currentY - startY;

            // Handle shape-specific logic
            if (this.tempElement.shapeType === 'line' || this.tempElement.shapeType === 'arrow') {
                // For lines and arrows, store end point
                this.tempElement.x = startX;
                this.tempElement.y = startY;
                this.tempElement.x2 = currentX;
                this.tempElement.y2 = currentY;

                // Shift constrains to 15° increments
                if (shiftKey) {
                    const dx = currentX - startX;
                    const dy = currentY - startY;
                    const angle = Math.atan2(dy, dx);
                    const snapAngle = Math.round(angle / (Math.PI / 12)) * (Math.PI / 12); // 15° increments
                    const length = Math.sqrt(dx * dx + dy * dy);
                    this.tempElement.x2 = startX + length * Math.cos(snapAngle);
                    this.tempElement.y2 = startY + length * Math.sin(snapAngle);
                }
            } else {
                // For other shapes, use width/height
                if (shiftKey) {
                    // Constrain to square/circle
                    const size = Math.max(Math.abs(width), Math.abs(height));
                    width = width >= 0 ? size : -size;
                    height = height >= 0 ? size : -size;
                }

                this.tempElement.x = width >= 0 ? startX : startX + width;
                this.tempElement.y = height >= 0 ? startY : startY + height;
                this.tempElement.width = Math.abs(width);
                this.tempElement.height = Math.abs(height);
            }
            break;

        case 'path':
            // Add point if moved enough
            const lastPoint = this.tempElement.points[this.tempElement.points.length - 1];
            const dist = Math.sqrt((currentX - lastPoint.x) ** 2 + (currentY - lastPoint.y) ** 2);
            if (dist > 2) {
                this.tempElement.points.push({ x: currentX, y: currentY });
            }
            break;
    }

    this.render();
}

updateResize(worldX, worldY, e) {
    if (!this.resizeHandle || this.selectedElements.length === 0) return;

    const element = this.selectedElements[0]; // Only resize first selected element
    const handle = this.resizeHandle;
    const shiftKey = e.shiftKey;

    if (element.type === 'shape' && (element.shapeType === 'line' || element.shapeType === 'arrow')) {
        // Special handling for lines/arrows
        if (handle === 'se') {
            element.x2 = worldX;
            element.y2 = worldY;
        } else if (handle === 'nw') {
            element.x = worldX;
            element.y = worldY;
        }
    } else {
        // Standard bounding box resize
        const originalWidth = element.width;
        const originalHeight = element.height;
        const originalX = element.x;
        const originalY = element.y;
        const aspectRatio = element.width / element.height;

        switch (handle) {
            case 'nw':
                element.width = originalX + originalWidth - worldX;
                element.height = originalY + originalHeight - worldY;
                element.x = worldX;
                element.y = worldY;
                break;
            case 'ne':
                element.width = worldX - originalX;
                element.height = originalY + originalHeight - worldY;
                element.y = worldY;
                break;
            case 'sw':
                element.width = originalX + originalWidth - worldX;
                element.height = worldY - originalY;
                element.x = worldX;
                break;
            case 'se':
                element.width = worldX - originalX;
                element.height = worldY - originalY;
                break;
            case 'n':
                element.height = originalY + originalHeight - worldY;
                element.y = worldY;
                break;
            case 's':
                element.height = worldY - originalY;
                break;
            case 'w':
                element.width = originalX + originalWidth - worldX;
                element.x = worldX;
                break;
            case 'e':
                element.width = worldX - originalX;
                break;
        }

        // Maintain aspect ratio with Shift
        if (shiftKey && handle.length === 2) { // Corner handles only
            element.height = element.width / aspectRatio;
            if (handle.includes('n')) {
                element.y = originalY + originalHeight - element.height;
            }
            if (handle.includes('w')) {
                element.x = originalX + originalWidth - element.width;
            }
        }

        // Prevent negative dimensions
        if (element.width < 10) element.width = 10;
        if (element.height < 10) element.height = 10;

        // Auto-scale text font size based on height for text elements
        if (element.type === 'text') {
            // Adjust font size proportionally to height
            const heightRatio = element.height / originalHeight;
            if (!element.originalFontSize) {
                element.originalFontSize = element.fontSize;
            }
            element.fontSize = Math.max(8, Math.round(element.originalFontSize * heightRatio));
        }
    }

    this.render();
}

getResizeHandle(worldX, worldY) {
    if (this.selectedElements.length !== 1) return null;

    const element = this.selectedElements[0];
    const handleSize = 8 / this.viewport.scale;

    if (element.type === 'shape' && (element.shapeType === 'line' || element.shapeType === 'arrow')) {
        // Line/arrow has endpoints only
        if (Math.abs(worldX - element.x) < handleSize && Math.abs(worldY - element.y) < handleSize) {
            return 'nw';
        }
        if (Math.abs(worldX - element.x2) < handleSize && Math.abs(worldY - element.y2) < handleSize) {
            return 'se';
        }
    } else {
        // Standard bounding box handles
        const handles = [
            { name: 'nw', x: element.x, y: element.y },
            { name: 'n', x: element.x + element.width / 2, y: element.y },
            { name: 'ne', x: element.x + element.width, y: element.y },
            { name: 'e', x: element.x + element.width, y: element.y + element.height / 2 },
            { name: 'se', x: element.x + element.width, y: element.y + element.height },
            { name: 's', x: element.x + element.width / 2, y: element.y + element.height },
            { name: 'sw', x: element.x, y: element.y + element.height },
            { name: 'w', x: element.x, y: element.y + element.height / 2 }
        ];

        for (const handle of handles) {
            if (Math.abs(worldX - handle.x) < handleSize && Math.abs(worldY - handle.y) < handleSize) {
                return handle.name;
            }
        }
    }

    return null;
}

getHandleCursor(handle) {
    if (!handle) return 'default';
    const cursors = {
        'nw': 'nw-resize',
        'n': 'n-resize',
        'ne': 'ne-resize',
        'e': 'e-resize',
        'se': 'se-resize',
        's': 's-resize',
        'sw': 'sw-resize',
        'w': 'w-resize'
    };
    return cursors[handle] || 'default';
}

triggerImageUpload(worldX, worldY) {
    const input = document.createElement('input');
    input.type = 'file';
    input.accept = 'image/*';
    input.onchange = (e) => {
        const file = e.target.files[0];
        if (file) {
            const reader = new FileReader();
            reader.onload = (event) => {
                const img = new Image();
                img.onload = () => {
                    this.elements.push({
                        type: 'image',
                        x: worldX,
                        y: worldY,
                        width: img.width,
                        height: img.height,
                        image: img,
                        src: event.target.result
                    });
                    this.render();
                };
                img.src = event.target.result;
            };
            reader.readAsDataURL(file);
        }
    };
    input.click();
}

startTextEditing(element) {
    if (element.type !== 'text') return;

    this.editingText = element;

    // Create input overlay
    const input = document.createElement('textarea');
    input.value = element.text;
    input.style.position = 'fixed';

    const screenPos = this.worldToScreen(element.x, element.y);
    input.style.left = screenPos.x + 'px';
    input.style.top = screenPos.y + 'px';
    input.style.width = (element.width * this.viewport.scale) + 'px';
    input.style.height = (element.height * this.viewport.scale) + 'px';
    input.style.fontSize = (element.fontSize * this.viewport.scale) + 'px';
    input.style.fontFamily = element.fontFamily;
    input.style.color = element.color;
    input.style.background = 'transparent';
    input.style.border = '1px solid #0099B8';
    input.style.outline = 'none';
    input.style.resize = 'none';
    input.style.padding = '4px';
    input.style.zIndex = '10000';

    this.textInput = input;
    document.body.appendChild(input);
    input.focus();
    input.select();

    const finishEditing = () => {
        element.text = input.value || 'Double-click to edit';
        document.body.removeChild(input);
        this.textInput = null;
        this.editingText = null;
        this.render();
    };

    input.addEventListener('blur', finishEditing);
    input.addEventListener('keydown', (e) => {
        if (e.key === 'Escape') {
            finishEditing();
        }
    });
}

stopTextEditing() {
    if (this.textInput && this.editingText) {
        this.editingText.text = this.textInput.value || 'Double-click to edit';
        document.body.removeChild(this.textInput);
        this.textInput = null;
        this.editingText = null;
        this.render();
    }
}

findElementAt(worldX, worldY) {
    for (let i = this.elements.length - 1; i >= 0; i--) {
        const el = this.elements[i];

        if (el.type === 'shape' && (el.shapeType === 'line' || el.shapeType === 'arrow')) {
            // Line hit detection
            const threshold = 5 / this.viewport.scale;
            const dist = this.pointToLineDistance(worldX, worldY, el.x, el.y, el.x2, el.y2);
            if (dist < threshold) return el;
        } else if (el.type === 'path') {
            // Path hit detection using bounding box with threshold
            const bounds = this.getPathBounds(el);
            const threshold = 5 / this.viewport.scale;  // 5px threshold

            // Check if point is within expanded bounding box
            if (worldX >= bounds.x - threshold &&
                worldX <= bounds.x + bounds.width + threshold &&
                worldY >= bounds.y - threshold &&
                worldY <= bounds.y + bounds.height + threshold) {
                // More precise check: distance to any line segment
                for (let i = 0; i < el.points.length - 1; i++) {
                    const p1 = el.points[i];
                    const p2 = el.points[i + 1];
                    const dist = this.pointToLineDistance(worldX, worldY, p1.x, p1.y, p2.x, p2.y);
                    if (dist < threshold) return el;
                }
            }
        } else {
            // Bounding box hit detection
            if (worldX >= el.x && worldX <= el.x + el.width &&
                worldY >= el.y && worldY <= el.y + el.height) {
                return el;
            }
        }
    }
    return null;
}

pointToLineDistance(px, py, x1, y1, x2, y2) {
    const A = px - x1;
    const B = py - y1;
    const C = x2 - x1;
    const D = y2 - y1;

    const dot = A * C + B * D;
    const lenSq = C * C + D * D;
    let param = -1;

    if (lenSq != 0) param = dot / lenSq;

    let xx, yy;

    if (param < 0) {
        xx = x1;
        yy = y1;
    } else if (param > 1) {
        xx = x2;
        yy = y2;
    } else {
        xx = x1 + param * C;
        yy = y1 + param * D;
    }

    const dx = px - xx;
    const dy = py - yy;
    return Math.sqrt(dx * dx + dy * dy);
}

// ==================== Rendering ====================

scheduleRender() {
    if (this.renderScheduled) return;

    this.renderScheduled = true;
    requestAnimationFrame(() => {
        this.render();
        this.renderScheduled = false;
    });
}

render() {
    // Clear canvas
    this.ctx.fillStyle = '#EAEFF5';
    this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

    // Draw background grid
    this.drawGrid();

    // Apply viewport transform
    this.ctx.save();
    this.ctx.translate(this.viewport.x, this.viewport.y);
    this.ctx.scale(this.viewport.scale, this.viewport.scale);

    // Render all elements
    this.elements.forEach(el => {
        if (el !== this.tempElement) {
            this.renderElement(el);
        }
    });

    // Render temporary element
    if (this.tempElement) {
        this.renderElement(this.tempElement);
    }

    // Render selection
    this.selectedElements.forEach(el => this.renderSelection(el));

    this.ctx.restore();
}

drawGrid() {
    const baseGridSize = 24;
    const dotSize = 1;
    const dotColor = 'rgba(7, 50, 71, 0.15)';

    // Skip grid rendering if zoom is too small to avoid artifacts
    if (this.viewport.scale < 0.05) return;

    // Adaptive grid spacing based on zoom level for performance
    let gridSize = baseGridSize;
    if (this.viewport.scale < 0.2) {
        gridSize = baseGridSize * 4; // Larger spacing at low zoom
    } else if (this.viewport.scale < 0.5) {
        gridSize = baseGridSize * 2;
    }

    this.ctx.fillStyle = dotColor;

    // Calculate visible bounds with padding
    const padding = 100;
    const startX = Math.floor((-this.viewport.x / this.viewport.scale - padding) / gridSize) * gridSize;
    const startY = Math.floor((-this.viewport.y / this.viewport.scale - padding) / gridSize) * gridSize;
    const endX = Math.ceil((this.canvas.width - this.viewport.x) / this.viewport.scale + padding) / gridSize * gridSize;
    const endY = Math.ceil((this.canvas.height - this.viewport.y) / this.viewport.scale + padding) / gridSize * gridSize;

    // Limit maximum number of grid dots for performance
    const maxDots = 5000;
    const estimatedDots = ((endX - startX) / gridSize) * ((endY - startY) / gridSize);

    if (estimatedDots > maxDots) {
        // Too many dots, increase spacing further
        gridSize *= Math.ceil(Math.sqrt(estimatedDots / maxDots));
    }

    for (let x = startX; x < endX; x += gridSize) {
        for (let y = startY; y < endY; y += gridSize) {
            const screenPos = this.worldToScreen(x, y);
            // Only draw dots that are within canvas bounds
            if (screenPos.x >= -10 && screenPos.x <= this.canvas.width + 10 &&
                screenPos.y >= -10 && screenPos.y <= this.canvas.height + 10) {
                this.ctx.fillRect(screenPos.x, screenPos.y, dotSize, dotSize);
            }
        }
    }
}

renderElement(el) {
    this.ctx.save();

    switch (el.type) {
        case 'page':
            this.pageCounter++;
            const pageSize = 800;
            this.tempElement = {
                id: 'page_' + Date.now(),
                type: 'page',
                x: worldX,
                y: worldY,
                width: pageSize,
                height: pageSize,
                fill: '#FFFFFF',
                stroke: '#E5E5E5',
                strokeWidth: 1,
                label: 'Page ' + this.pageCounter
            };
            this.elements.push(this.tempElement);
            this.tempElement = null;
            this.setTool('move');
            break;

        case 'image':
            if (el.image) {
                this.ctx.drawImage(el.image, el.x, el.y, el.width, el.height);
            }
            break;

        case 'text':
            this.ctx.font = `${el.fontSize}px ${el.fontFamily}`;
            this.ctx.fillStyle = el.color;
            this.ctx.textAlign = el.align || 'left';
            this.ctx.textBaseline = 'top';

            // Smart text rendering to fill the box
            const padding = 5;
            const words = el.text.split(' ');
            let line = '';
            let y = el.y + padding;
            const lineHeight = el.fontSize * 1.2;
            const maxWidth = el.width - padding * 2;

            // Try to fit text in box by adjusting line breaks
            for (let i = 0; i < words.length; i++) {
                const testLine = line + (line ? ' ' : '') + words[i];
                const metrics = this.ctx.measureText(testLine);

                if (metrics.width > maxWidth && line !== '') {
                    this.ctx.fillText(line, el.x + padding, y);
                    line = words[i];
                    y += lineHeight;

                    // Stop if we've exceeded box height
                    if (y + lineHeight > el.y + el.height) break;
                } else {
                    line = testLine;
                }
            }

            // Draw last line if within bounds
            if (line && y + lineHeight <= el.y + el.height + padding) {
                this.ctx.fillText(line, el.x + padding, y);
            }
            break;

        case 'page':
            this.ctx.fillStyle = el.fill || '#FFFFFF';
            this.ctx.fillRect(el.x, el.y, el.width, el.height);
            this.ctx.strokeStyle = el.stroke || '#E5E5E5';
            this.ctx.lineWidth = el.strokeWidth || 1;
            this.ctx.strokeRect(el.x, el.y, el.width, el.height);

            if (el.label) {
                this.ctx.save();
                this.ctx.resetTransform();
                const screenPos = this.worldToScreen(el.x + 10, el.y + 10);
                this.ctx.font = '14px Inter, sans-serif';
                this.ctx.fillStyle = '#666666';
                this.ctx.fillText(el.label, screenPos.x, screenPos.y);
                this.ctx.restore();
            }
            break;

        case 'shape':
            this.renderShape(el);
            break;

        case 'path':
            this.ctx.beginPath();
            el.points.forEach((p, i) => {
                if (i === 0) this.ctx.moveTo(p.x, p.y);
                else this.ctx.lineTo(p.x, p.y);
            });
            this.ctx.strokeStyle = el.stroke;
            this.ctx.lineWidth = el.strokeWidth;
            this.ctx.lineCap = 'round';
            this.ctx.lineJoin = 'round';
            this.ctx.stroke();
            break;
    }

    this.ctx.restore();
}

renderShape(el) {
    const shapeType = el.shapeType || 'rectangle';

    this.ctx.beginPath();

    switch (shapeType) {
        case 'rectangle':
            if (el.cornerRadius && el.cornerRadius > 0) {
                this.roundRect(el.x, el.y, el.width, el.height, el.cornerRadius);
            } else {
                this.ctx.rect(el.x, el.y, el.width, el.height);
            }
            break;

        case 'ellipse':
            this.ctx.ellipse(
                el.x + el.width / 2,
                el.y + el.height / 2,
                el.width / 2,
                el.height / 2,
                0, 0, Math.PI * 2
            );
            break;

        case 'line':
            this.ctx.moveTo(el.x, el.y);
            this.ctx.lineTo(el.x2, el.y2);
            break;

        case 'arrow':
            this.drawArrow(el.x, el.y, el.x2, el.y2);
            break;

        case 'polygon':
        case 'star':
            // TODO: Implement polygon and star
            this.ctx.rect(el.x, el.y, el.width, el.height);
            break;
    }

    if (el.fill && el.fill !== 'none') {
        this.ctx.fillStyle = el.fill;
        this.ctx.fill();
    }

    if (el.stroke && el.strokeWidth > 0) {
        this.ctx.strokeStyle = el.stroke;
        this.ctx.lineWidth = el.strokeWidth;
        this.ctx.stroke();
    }
}

drawArrow(x1, y1, x2, y2) {
    const headLength = 15;
    const angle = Math.atan2(y2 - y1, x2 - x1);

    // Draw line
    this.ctx.moveTo(x1, y1);
    this.ctx.lineTo(x2, y2);

    // Draw arrowhead
    this.ctx.lineTo(
        x2 - headLength * Math.cos(angle - Math.PI / 6),
        y2 - headLength * Math.sin(angle - Math.PI / 6)
    );
    this.ctx.moveTo(x2, y2);
    this.ctx.lineTo(
        x2 - headLength * Math.cos(angle + Math.PI / 6),
        y2 - headLength * Math.sin(angle + Math.PI / 6)
    );
}

roundRect(x, y, width, height, radius) {
    this.ctx.moveTo(x + radius, y);
    this.ctx.lineTo(x + width - radius, y);
    this.ctx.quadraticCurveTo(x + width, y, x + width, y + radius);
    this.ctx.lineTo(x + width, y + height - radius);
    this.ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
    this.ctx.lineTo(x + radius, y + height);
    this.ctx.quadraticCurveTo(x, y + height, x, y + height - radius);
    this.ctx.lineTo(x, y + radius);
    this.ctx.quadraticCurveTo(x, y, x + radius, y);
}

renderSelection(el) {
    const padding = 2 / this.viewport.scale;

    // Use #0099B8 color and 1px solid border
    this.ctx.strokeStyle = '#0099B8';
    this.ctx.lineWidth = 1 / this.viewport.scale;
    this.ctx.setLineDash([]);

    if (el.type === 'shape' && (el.shapeType === 'line' || el.shapeType === 'arrow')) {
        // Selection for lines - show endpoints
        const handleSize = 8 / this.viewport.scale;

        this.ctx.fillStyle = '#FFFFFF';
        this.ctx.strokeStyle = '#0099B8';
        this.ctx.lineWidth = 1 / this.viewport.scale;

        // Start point
        this.ctx.fillRect(el.x - handleSize / 2, el.y - handleSize / 2, handleSize, handleSize);
        this.ctx.strokeRect(el.x - handleSize / 2, el.y - handleSize / 2, handleSize, handleSize);

        // End point
        this.ctx.fillRect(el.x2 - handleSize / 2, el.y2 - handleSize / 2, handleSize, handleSize);
        this.ctx.strokeRect(el.x2 - handleSize / 2, el.y2 - handleSize / 2, handleSize, handleSize);
    } else if (el.type === 'path') {
        // Path selection - show bounding box
        const bounds = this.getPathBounds(el);

        this.ctx.strokeRect(
            bounds.x - padding,
            bounds.y - padding,
            bounds.width + padding * 2,
            bounds.height + padding * 2
        );

        // Draw corner handles only for paths (no resize for now)
        const handleSize = 8 / this.viewport.scale;
        const handles = [
            { x: bounds.x, y: bounds.y },
            { x: bounds.x + bounds.width, y: bounds.y },
            { x: bounds.x + bounds.width, y: bounds.y + bounds.height },
            { x: bounds.x, y: bounds.y + bounds.height }
        ];

        this.ctx.fillStyle = '#FFFFFF';
        this.ctx.strokeStyle = '#0099B8';
        this.ctx.lineWidth = 1 / this.viewport.scale;

        handles.forEach(handle => {
            this.ctx.fillRect(
                handle.x - handleSize / 2,
                handle.y - handleSize / 2,
                handleSize,
                handleSize
            );
            this.ctx.strokeRect(
                handle.x - handleSize / 2,
                handle.y - handleSize / 2,
                handleSize,
                handleSize
            );
        });
    } else {
        // Standard bounding box selection
        this.ctx.strokeRect(
            el.x - padding,
            el.y - padding,
            el.width + padding * 2,
            el.height + padding * 2
        );

        // Draw resize handles
        const handleSize = 8 / this.viewport.scale;
        const handles = [
            { x: el.x, y: el.y },
            { x: el.x + el.width / 2, y: el.y },
            { x: el.x + el.width, y: el.y },
            { x: el.x + el.width, y: el.y + el.height / 2 },
            { x: el.x + el.width, y: el.y + el.height },
            { x: el.x + el.width / 2, y: el.y + el.height },
            { x: el.x, y: el.y + el.height },
            { x: el.x, y: el.y + el.height / 2 }
        ];

        this.ctx.fillStyle = '#FFFFFF';
        this.ctx.strokeStyle = '#0099B8';
        this.ctx.lineWidth = 1 / this.viewport.scale;

        handles.forEach(handle => {
            this.ctx.fillRect(
                handle.x - handleSize / 2,
                handle.y - handleSize / 2,
                handleSize,
                handleSize
            );
            this.ctx.strokeRect(
                handle.x - handleSize / 2,
                handle.y - handleSize / 2,
                handleSize,
                handleSize
            );
        });
    }

    this.ctx.setLineDash([]);
}

// Calculate bounding box for path
getPathBounds(path) {
    if (!path.points || path.points.length === 0) {
        return { x: 0, y: 0, width: 0, height: 0 };
    }

    let minX = path.points[0].x;
    let minY = path.points[0].y;
    let maxX = path.points[0].x;
    let maxY = path.points[0].y;

    path.points.forEach(p => {
        minX = Math.min(minX, p.x);
        minY = Math.min(minY, p.y);
        maxX = Math.max(maxX, p.x);
        maxY = Math.max(maxY, p.y);
    });

    return {
        x: minX,
        y: minY,
        width: maxX - minX,
        height: maxY - minY
    };
}
}
